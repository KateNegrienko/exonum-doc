# Обзор Архитектуры

<!-- cspell:ignore postgre -->

Данная страница описывает основные архитектурные решения инфраструктуры Exonum:
[обработку транзакций](#обработка-транзакций),
[структуру сети](#структура-сети),
[алгоритм консенсуса](#консенсус),
[организацию хранения данных](#хранение-данных),
[сервисы](#модульность-и-сервисы),
и [криптографию используемую в Exonum](#криптография).

## Обработка Транзакций

Для внешнего приложения, блокчейн на Exonum представляет собой хранилище типа
ключ-значение и [онлайн средство обработки транзакций][wiki:oltp], управляющее
этим хранилищем. Его основные функции - обработка транзакций, сохранение данных
и ответы на запросы на чтение от внешних клиентов.

**Транзакции** - это основной объект, с которым работает Exonum. Транзакция
представляет собой атомарный патч, который применяется к хранилищу типа
ключ-значение. Транзакции аутентифицируются с помощью цифровых подписей с
открытым ключом. Транзакции должны быть проверены и упорядоченны до того, как
они будут считаться принятыми / совершенными. Упорядочение выполняется по
[алгоритму консенсуса](#консенсус); алгоритм также гарантирует, что будут
совершены только успешно проверенные транзакции.

Транзакции строятся по шаблону; каждый шаблон транзакции имеет набор переменных,
которые влияют на выполнение транзакции и используются для сериализации
транзакций для передачи по сети и сохранения. (Следовательно, транзакции можно
сравнить с хранимыми процедурами в реляционных СУБД). Шаблоны транзакций и
правила обработки для каждого шаблона определяются
[сервисами](#модульность-и-сервисы). В частности, сервисы определяют правила
проверки транзакций и способ применения транзакций к хранилищу типа
ключ-значение.

Все данные в блокчейне Exonum разделены на две части:

- **Хранилище данных**, которое содержит данные, структурированные в таблицы
- **Журнал транзакций**, т.е. полная история всех транзакций, когда-либо
применявшихся к хранилищу данных

Поскольку транзакции включают операции с хранилищем типа ключ-значение, такие,
как создание нового значения или обновление уже сохраненных значений,
фактическое состояние хранилища данных может быть полностью восстановлено из
журнала транзакций. Когда в сети Exonum появляется новый узел, он скачивает
уже сгенерированные блоки и применяет транзакции с этих блоков к хранилищу
данных одна за другой. Такой подход позволяет видеть всю историю любого
фрагмента данных и упрощает аудит.

Используя журнал транзакций, Exonum реализует
[репликацию][wiki:state-machine-repl]для достижения отказоустойчивости.
Это гарантирует согласование состояний хранилища данных между узлами сети.
Такой же подход часто используют неблокчейновые распределенные БД, такие,
как MongoDB или PostgreSQL.

### Блоки

Exonum собирает транзакции в **блоки**; весь блок одобрен атомарно. Если
транзакция еще не была записана в какой-либо блок, она не считается принятой.
После утверждения блока каждая транзакция в нем выполняется последовательно,
и изменения применяются к хранилищу данных.

Блоки Exonum состоят из следующих частей:

- Хеш предыдущего блока Exonum
- Список одобренных транзакций. Когда узлы выполняют блок, они выполняют каждую
транзакцию в указанном порядке и применяют изменения в своих хранилищах данных.
Каждый тип транзакции выполняется соответствующим сервисом Exonum
- Хеш нового состояния хранилища данных. Само состояние не включено здесь;
однако операции применяются детерминистически и недвусмысленно. Согласование
хеша хранилища данных является частью алгоритма консенсуса Exonum, поэтому хеш
гарантированно совпадает для всех валидаторов

Поскольку каждый блок включает хеш предыдущего блока, невозможно изменить один
блок без соответствующих изменений в каждом из следующих блоков. Это
гарантирует неизменность журнала транзакций; после совершения транзакции, она
не может быть изменена или выведена из журнала задним числом. Точно так же
невозможно вставить транзакцию в середине журнала.

!!! note "Примечание"
    Согласование хеша хранилища данных не только означает, что полные узлы
    выполняют транзакции в одном и том же порядке; они также должны выполнять
    все транзакции одинаково. Это защищает от сценария, в котором результаты
    выполнения отличаются среди узлов в сети (например, из-за
    недетерминированных инструкций в коде выполнения транзакции), что может
    привести к возникновению различных проблем.

## Структура Сети

Сеть Exonum состоит из *полных узлов*, подключенных через одноранговые
соединения и *легких клиентов*.

### Полные Узлы

**Полные узлы** копируют все содержимое блокчейна и соответствуют репликам в
распределенных базах данных. Все полные узлы аутентифицируются с помощью
криптосистемы с открытым ключом. Полные узлы подразделяются на 2 категории:

- **Аудиторы** копируют всю информацию блокчейна. Они могут генерировать новые
  транзакции, но не могут выбирать, какие транзакции должны быть совершены
  (т.е. не могут генерировать новые блоки)
- Валидаторы обеспечивают жизнеспособность сети. Только валидаторы могут
  генерировать новые блоки, используя
  [алгоритм византийского консенсуса](#консенсус).
  Валидаторы получают транзакции, проверяют их и включают в новый блок. Список
  валидаторов ограничен разработчиками сети и обычно должен состоять из 4-15 узлов

### Легкие Клиенты

**Легкие клиенты** представляют клиентов в парадигме клиент-сервер; они
подключаются к полным узлам для извлечения нужной им информации из блокчейна,
и для отправки транзакций. Exonum предоставляет «механизм доказательств»,
основанный на криптографических обязательствах через деревья хешей. Этот
механизм позволяет проверить, что ответ от полного узла был действительно
одобрен большинством валидаторов.

## Консенсус

Exonum использует индивидуальную модификацию византийского консенсуса (похожего
на PBFT), чтобы гарантировать, что в любой момент существует одна
согласованная версия блокчейна. Предполагается, что среда децентрализована,
т.е. любой узел может выйти из строя или быть скомпрометирован. Консенсус
*аутентифицирован*; участники консенсуса (т.е. валидаторы) идентифицируются
с помощью криптосистемы с открытым ключом.

Чтобы создать новый блок и проголосовать за него, используется трехфазный
подход.

- Алгоритм консенсуса делится на раунды, начало которых определяется каждым
  валидатором на основе его локальных часов. Для каждого раунда существует
  предопределенный валидатор лидер, который определяется на основе числа раундов,
  высоты цепочки и другой информации из состояния блокчейна. Лидер создает
  *предложение блока (proposal)* и отправляет его другим валидаторам
- Другие валидаторы проверяют это предложение, и если оно правильно, голосуют
  за него, передавая сообщения типа *prevote* другим валидаторам
- Если валидатор собирает сообщения типа *prevote* для одного и того же
  предложения от квалифицированного большенства валидаторов, он выполняет
  транзакции в предложении, создает сообщение типа *precommit* с новым
  состоянием хранилища данных и отправляет его валидаторам
- В конце, если валидатор получает сообщения типа *precommit* от
  квалифицированного большинства валидаторов для одного и того же предложения,
  предложение становится новым блоком и фиксируется в локальном хранилище
  валидатора

!!! note "Примечание"
    Блок может быть зафиксирован в разное время для разных валидаторов.
    Алгоритм консенсуса гарантирует, что валидаторы не могут фиксировать
    разные блоки на одной и той же высоте (см.
    [свойство безопасности](#безопасность-и-жизнеспособность)
    ниже).

Если валидатор не получает правильное предложение блока в определенном раунде,
он в конечном итоге переходит к следующему раунду по истечении времени
ожидания и готов рассматривать предложения от лидера в новом раунде.

Алгоритм консенсуса может выдерживать ситуации когда до 1/3 валидаторов
действуют злонамеренно, отключены или изолированы от сети. Это лучшее
возможное показание в условиях, в которых консенсус Exonum работает (частичная
синхронность, которую можно резюмировать как отсутствие отсчета времени в
системе). Например, лидер не может своевременно создать предложение или
отправить различные предложения разным валидаторам; в конечном счете, все
честно действующие валидаторы одобрят один и тот же новый блок.

Валидаторы могут быть изменены во время роботы блокчейна путем
[обновления](#сервис-обновления-конфигурации)
глобальной конфигурации блокчейна. Этот механизм можно использовать для оборота
ключей валидаторов, а также для добавления, замены или удаления узлов
валидаторов без необходимости запуска блокчейна заново.

### Безопасность и Жизнеспособность

Говоря технически, алгоритм консенсуса, используемый в Exonum, гарантирует
2 основных свойства:

- **Безопасность** означает, что, как только один правильно действующий
  валидатор зафиксирует блок, все остальные правильно действующие валидаторы в
  конечном итоге зафиксируют этот же блок на той же высоте; другими словами,
  блокчейн не может разделиться
- **Жизнеспособность** означает, что правильно действующие валидаторы
  продолжают время от времени фиксировать блоки

Эти свойства формально доказаны для алгоритма консенсуса действующего в
частично синхронной сети, в условиях что до 1/3 узлов валидаторов
скомпрометированы или не реагируют. Если сеть является асинхронной (т.е.
между валидаторами существует произвольная высокая задержка соединения),
алгоритм гарантирует безопасность, но может потерять жизнеспособность.
То же самое происходит в большинстве сценариев, в которых скомпрометировано
более 1/3 (но менее 2/3) валидаторов.

## Хранение Данных

### RocksDB

[RocksDB][rocks-db] используется для локального хранения данных, с которыми
работают транзакции. Этот механизм хранения обеспечивает высокую эффективность
и минимальные затраты на хранение.

### Типы Таблиц

Exonum поддерживает несколько типов таблиц данных, представляющих собой
типизированные коллекции (списки, наборы и карты):

- `ListIndex` реализует список массивов
- `MapIndex` представляет собой карту / хранилище типа ключ-значение
- [`ProofListIndex`](../architecture/storage.md#prooflistindex)
  представляет собой расширенная версия хранилища массивов. Он реализует
  сбалансированное (но не обязательно полное) двоичное дерево хешей. Листья
  дерева сохраняют фактические элементы массива, в то время как промежуточные
  вершины сохраняют хеши от составных данных дочерних вершин. `ProofListIndex`
  позволяет только добавлять данные или обновлять уже сохраненные элементы
- [`ProofMapIndex`](../architecture/storage.md#proofmapindex)
  расширяет карту. Он основан на дереве типа Merkle Patricia, реализованном
  как двоичное дерево. Листья дерева сохраняют фактические значения с карты.
  Промежуточные узлы состоят из следующих четырех частей:

    - Хеш левого дочернего значения
    - Хеш правого дочернего значения
    - Ключ для левого дочернего узла
    - Ключ для правого дочернего узла

- `ValueSetIndex` и `KeySetIndex` реализуют наборы, и оба сводят их к
картам (как это обычно делается в языках программирования). `ValueSetIndex`
отображает хеши элементов набора как сами элементы, в то время как `KeySetIndex`
отображает элементы набора как `null`. Таким образом, `KeySetIndex`
предпочтительнее, когда заданные элементы имеют относительно короткую
сериализацию и есть потребность повторять их в определенном порядке.
`ValueSetIndex` лучше подходит для сложных элементов или элементов, которые
нужно искать с помощью хеша.

Both `ListIndex` and `ProofListIndex` support updating by index and
appending only. `MapIndex` and `ProofMapIndex` allow inserting,
updating or deleting key-value pairs. `KeySetIndex` and `ValueSetIndex` support
adding and removing elements from the set. Finally, all collections support
iterations over items (or keys, values, and key-value pairs in the case of
  maps).

### Доказательства

`ProofListIndex` и `ProofMapIndex` позволяют эффективно создавать
доказательства того, что определенные значения сохраняются под определенными
ключами. Чтобы доказать это, достаточно вернуть список хешей из корня дерева к
определенной ячейке (путь Merkle). Таблицы Merkle Patricia также позволяют
создавать доказательства того, что в базе данных нет данных с определенным
ключом.

Когда полный узел связывается с легким клиентом, доказательства возвращаются
вместе с запрошенными данными. Это позволяет эффективно доказывать
достоверность данных.

## Модульность и Сервисы

Помимо ядра, Exonum включает в себя фреймворк для создания **сервисов**. В то
время как ядро ​​отвечает за консенсус и играет роль промежуточного программного
обеспечения для отправки и получения транзакций и блоков, сервисы реализуют
всю бизнес-логику блокчейна и являются основной точкой расширения функционала
Exonum.

Сервисы Exonum взаимодействуют с внешним миром с помощью *конечных точек*.
Сервис может определять 3 типа конечных точек:

- **Транзакции** соответствуют методам `POST / PUT` для веб-служб REST. Они
  преобразуют состояние блокчейна. Все транзакции в блокчейне полностью
  упорядочены, как описано выше, и результат их выполнения согласован между
  полными узлами в сети блокчейн
- **Запросы на чтение** соответствуют методам GET для веб-служб. Они извлекают
  информацию из блокчейна, возможно, вместе с доказательствами. Запросы на
  чтение выполняются локально, не являются глобально упорядоченными и не могут
  изменять состояние блокчейна
- **Частные конечные точки** предоставляют административный интерфейс
  локальному экземпляру сервиса. Они могут использоваться для настройки
  локальной конфигурации сервиса, например, для управления приватными ключами,
  специфичными для сервисов. Частные конечные точки выполняются локально, не
  являются глобально упорядоченными и не могут напрямую изменять состояние
  блокчейна (хотя они могут генерировать транзакции и добавлять их в сеть)

!!! note "Примечание"
    Еще один тип конечных точек, *событие*,
    [будет доступен в скором времени.](../roadmap.md).
    События будут реализовывать [шаблон проектирования издатель-подписчик][wiki:pubsub],
    позволяя легким клиентам и сервисам подписываться на события, которые
    выпускаются сервисами.

Внешние приложения могут связываться с сервисными конечными точками через
HTTP REST API, используя JSON в качестве формата сериализации. Exonum облегчает
задачи промежуточного программного обеспечения для сервисов, такие как
прослушивание HTTP-запросов, отправка входящих транзакций и запросов на чтение
в соответствующий сервис, выполнение преобразования в JSON и обратно, и т. д.

Поскольку сервисы являются модулями Rust, их можно легко использовать повторно
в проектах Exonum. Вы можете использовать сервисы с открытым исходным кодом,
уже написанные сообществом, или создать свой собственный сервис.

### Смарт-контракты

Конечные точки, определяемые сервисами, выполняют ту же роль, что и
смарт-контракты на других блокчейн платформах. Они определяют бизнес-логику
блокчейна, позволяют извлекать данные из блокчейна и могут быть повторно
использованы в разных проектах. Частичные аналоги для этой модели выполнения -
это конечные точки веб-служб REST и хранимые процедуры для систем управления
базами данных.

Следующие ключевые моменты отличают смарт-контракты Exonum от других моделей,
используемых в блокчейнах:

- **Ограниченная среда.** Exonum выполняет только предопределенные типы
  запросов, не позволяя выполнять ненадежный код полученный от клиента. Это
  приводит к более контролируемой среде и упрощает аргументирование безопасности
  смарт-контрактов
- **Отсутствие изоляции.** Обработка запросов выполняется в том же контексте
  выполнения, что и ядро ​​системы. Это выигрышно сказывается на
  производительности, хотя и имеет определенные риски по отношению к
  безопасности
- **Локальное состояние.** Сервисы Exonum могут определять локальное состояние,
  которое относится к узлу, на котором работает сервис. Локальное состояние может
  использоваться для управления секретной информацией (например, приватными
  ключами). Локальное состояние может управляться конечными точками приватного
  сервиса. Используя локальное состояние, сервисы могут быть более активными,
  чем их аналоги в других блокчейнах. Например,
  [сервис анкоринга](#сервис-анкоринга)
  использует локальное состояние для полной автоматизации подписания анкорящих
  транзакций
- **Разделение обработки транзакций.** Проверка транзакций - это отдельный шаг
  обработки транзакций. Он выполняется сразу после получения транзакции, прежде
  чем применять транзакцию к состоянию блокчейна. Проверка может включать
  проверку подлинности (например, проверку подписи транзакции), а также другие
  структурные проверки содержимого транзакции. В то же время проверка транзакции
  не имеет доступа к текущему состоянию блокчейна

!!! note "Примечание"
    Изоляция выполнения сервисов является высокоприоритетной задачей
    в [дорожной карте Exonum](../roadmap.md).

### Существующие Сервисы

#### Сервис Обновления Конфигурации

Хотя каждый узел имеет свой собственный файл конфигурации, некоторые настройки
должны быть изменены для всех узлов одновременно. Данный сервис позволяет
обновлять конфигурацию с помощью самого блокчейна.

Используя сервис обновления конфигурации, любой валидатор может предлагать
новую конфигурацию, и другие валидаторы могут голосовать за нее. Для
применения предлагаемых изменений требуется одобрение от квалифицированного
большинства валидаторов; однако изменения все еще неактивны, и текущие
настройки все еще используются. Новая конфигурация включает параметр
`actual_from` указывающий на высоту, при достижении которой активируется новая
конфигурация.

#### Сервис Анкоринга

Сервис анкоринга записывает хеш текущего состояния блокчейна Exonum в блокчейн
Биткойн с определенным интервалом времени. Данные для анкоринга
аутентифицируются квалифицированным большинством валидаторов с помощью
инструментов цифровой подписи доступных в Биткойне.

Анкоринг повышает безопасность системы; даже если злоумышленник получит
контроль над каждым валидатором или все валидаторами вступят в заговор,
невозможно незаметно изменить журнал транзакций. После любого изменения,
модифицированные задним числом хеши блоков будут отличаться от тех, которые
записаны в Биткойн блокчейне. Чтобы задним числом изменить данные в блокчейне
Exonum, злоумышленнику также необходимо будет скомпрометировать Биткойн
блокчейн. Стоимость такой атаки будет измеряться в миллиардах долларов США.

Кроме того, заанкоренные данные вместе с доказательствами остаются поддающимися
проверке, даже если блокчейн Exonum по какой-то причине станет недоступен. Это
свойство может быть использовано для обеспечения надежных электронных квитанций.

## Криптография

### Хеширование

Exonum использует [SHA-256][wiki:sha256] для всех операций хеширования, включая
создание идентификаторов транзакций и блоков, вычисление деревьев хешей и
сопоставление ключей деревьев хешей для байтовых буферов с фиксированной длиной.

### Криптосистема с Открытым Ключом и Управление Ключами

Как транзакции, так и сообщения относящиеся к консенсусу аутентифицируются с
помощью [цифровых подписей Ed25519][wiki:ed25519] реализованных с
использованием [sodiumoxide][sodiumoxide] (оболочка [libsodium][libsodium] для
Rust). В большинстве случаев транзакции создаются внешними объектами (такими
как легкие клиенты); предполагается, что эти сущности управляют
соответствующими ключами подписи. Ключами также могут управлять сами полные
узлы. В этом случае приватный ключ хранится в локальной конфигурации узла,
не входит в блокчейн и уникален для конкретного узла. Оптимальная практика
заключается в том, чтобы управлять такими ключами локально через приватные
API соответствующего сервиса.

Ядро Exonum определяет две пары ключей Ed25519 для полных узлов:

- **Ключ консенсуса** используется для подписания сообщений относящихся к
  консенсусу (для валидаторов) и подписания сетевых сообщений (для валидаторов
  и аудиторов)
- **Административный ключ** имеется только у валидаторов и используется для
  административных задач (таких, как голосование за обновления конфигурации)

Сервисы могут использовать дополнительные пары ключей, в том числе из других
криптосистем. Например, сервис анкоринга определяет дополнительную пару ключей
secp256k1 для подписания анкорящих транзакций в Биткойне.

!!! warning "Примечание"
    В настоящее время локальная конфигурация узла (который включает в себя все
    его приватные ключи, используемые как в консенсусе, так и в сервисах)
    хранится в виде открытого текста. Скоро это будет исправлено.

!!! note "Предупреждение"
    В настоящее время административные ключи являются горячими (т.е. хранятся
    в незашифрованном виде во время операций с узлом). В будущих версиях можно
    будет управлять ими как хранящимися внешне холодными ключами (то есть, у
    узла вообще не будет доступа к административному ключу). Кроме того,
    соответствие 1-к-1 между ключами консенсуса и административными ключами
    будет обобщено для поддержки различных административных настроек.

[arch-guide]: https://github.com/exonum/exonum/blob/master/ARCHITECTURE.md
[wiki:oltp]: https://en.wikipedia.org/wiki/Online_transaction_processing
[wiki:state-machine-repl]: https://en.wikipedia.org/wiki/State_machine_replication
[rocks-db]: http://rocksdb.org/
[wiki:sha256]: https://en.wikipedia.org/wiki/SHA-2
[wiki:ed25519]: https://en.wikipedia.org/wiki/EdDSA
[libsodium]: https://download.libsodium.org/doc/
[sodiumoxide]: https://dnaq.github.io/sodiumoxide/sodiumoxide/
[wiki:pubsub]: https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern
